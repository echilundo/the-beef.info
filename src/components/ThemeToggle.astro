---
import SunIcon from "@components/icons/SunIcon.astro";
import MoonIcon from "@components/icons/MoonIcon.astro";

interface Props {
  class?: string;
}

const { class: className = "" } = Astro.props;
---

<div class={`flex flex-wrap gap-1 items-center ${className}`} role="group" aria-label="Theme selection">
  <!-- Light Theme Button -->
  <button
    id="light-theme-button"
    aria-label="Switch to light theme"
    aria-pressed="false"
    class="group size-8 flex items-center justify-center rounded-full light-theme-button focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900"
    type="button"
  >
    <SunIcon />
    <span class="sr-only">Switch to light theme</span>
  </button>
  
  <!-- Dark Theme Button -->
  <button
    id="dark-theme-button"
    aria-label="Switch to dark theme"
    aria-pressed="false"
    class="group size-8 flex items-center justify-center rounded-full dark-theme-button focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900"
    type="button"
  >
    <MoonIcon />
    <span class="sr-only">Switch to dark theme</span>
  </button>
</div>

<script>
  // Theme toggle functionality with enhanced accessibility
  const lightButton = document.getElementById('light-theme-button');
  const darkButton = document.getElementById('dark-theme-button');

  const updateThemeButtons = () => {
    const isDark = document.documentElement.classList.contains('dark');
    
    if (lightButton && darkButton) {
      // Update visual state
      (lightButton as HTMLElement).style.opacity = isDark ? '0.5' : '1';
      (darkButton as HTMLElement).style.opacity = isDark ? '1' : '0.5';
      
      // Update ARIA attributes
      lightButton.setAttribute('aria-pressed', (!isDark).toString());
      darkButton.setAttribute('aria-pressed', isDark.toString());
      
      // Update aria-labels for screen readers
      lightButton.setAttribute('aria-label', isDark ? 'Switch to light theme' : 'Currently using light theme');
      darkButton.setAttribute('aria-label', isDark ? 'Currently using dark theme' : 'Switch to dark theme');
    }
  };

  const setTheme = (theme: 'light' | 'dark') => {
    localStorage.setItem('theme', theme);
    document.documentElement.classList.toggle('dark', theme === 'dark');
    updateThemeButtons();
    
    // Announce theme change to screen readers
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only';
    announcement.textContent = `Switched to ${theme} theme`;
    document.body.appendChild(announcement);
    
    // Remove announcement after screen reader has time to read it
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  };

  // Enhanced keyboard navigation
  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
      event.preventDefault();
      const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
      const newTheme = event.key === 'ArrowLeft' ? 'light' : 'dark';
      if (currentTheme !== newTheme) {
        setTheme(newTheme);
        // Focus the newly active button
        const targetButton = newTheme === 'light' ? lightButton : darkButton;
        targetButton?.focus();
      }
    }
  };

  // Event listeners
  lightButton?.addEventListener('click', () => setTheme('light'));
  darkButton?.addEventListener('click', () => setTheme('dark'));
  
  // Keyboard navigation
  lightButton?.addEventListener('keydown', handleKeyDown);
  darkButton?.addEventListener('keydown', handleKeyDown);

  // Initialize theme buttons
  document.addEventListener('DOMContentLoaded', updateThemeButtons);
  
  // Update buttons when theme changes
  const observer = new MutationObserver(updateThemeButtons);
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class']
  });
</script>
